@tool
extends _dt_common
class_name _dt_class_generator

static var _INSTANCE: _dt_class_generator

func delete():
	_INSTANCE = null

static func get_instance() -> _dt_class_generator:
	
	if !_INSTANCE:
		_INSTANCE = _dt_class_generator.new()
		_INSTANCE.load_var()
	
	return _INSTANCE

var _BASE_TEMPLATE = str(
	"## This is a class generated by the DataTable plugin for Godot\n",
	"## \n",
	"## Created by Ward, Copyright MIT License\n",
	"## More info: https://github.com/Ward727a/godot_datatable_plugin\n")

# Init

func load_var():
	
	pass

func generate(structure: Dictionary):
	
	var content = ""
	
	var getters = []
	var setters = []
	
	var variables = []
	
	## Separate each data from the structure
	var name = structure['name'].replace(' ', "_")
	var params = structure['params']
	
	## First we add the base_template
	content += _BASE_TEMPLATE
	
	## Adding the class_name
	content += _get_class(name)
	
	## Adding space
	content += "\n\n"
	
	## Adding each var parameters
	for i in params:
		var param = params[i]
		
		variables.append(param['name'].replace(' ', "_"))
		
		content += _get_var(param)
		
		setters.append(_get_setter(param))
		getters.append(_get_getter(param))
	
	## adding some spaces
	
	content += "\n\n"
	
	## adding init function
	
	content += _get_init(variables)
	
	## space
	
	content += "\n"
	
	for i in setters:
		content += i
		content += "\n"
	
	for i in getters:
		content += i
		content += "\n"
	
	return content


func _get_class(name: String):
	return str(
		"extends Structure\n",
		"class_name struct_",name)

func _get_var(var_data: Dictionary):
	
	var content = "var "
	
	var name = var_data['name'].replace(' ', "_")
	var type = var_data['type']
	var default = ""
	if var_data.has('default'):
		default = var_data['default']
	var size = var_data['size']
	var comment = var_data['comment']
	
	var type_as_string = ""
	
	if size == self.SIZE_SINGLE:
		type_as_string = _get_varType_to_String(type)
	else:
		default = "[]"
		type_as_string = _get_varArray_to_String(type)
	
	var default_as_string = _convert_hard_to_soft_value(type, default)
	
	var comment_as_string
	
	if !comment.is_empty():
		comment_as_string = " ## "+comment
	
	# adding name
	content += str("_",name, ": ")  # |var _name:
	
	# adding type
	content += str(type_as_string , " = ") # |var name: String = 
	
	# adding default_value
	content += default_as_string
	
	# adding comment if any
	if !comment_as_string.is_empty():
		content = str(comment_as_string, "\n", content)
	
	# add return to blankline
	content += "\n"
	
	return content

func _get_varArray_to_String(type: int):
	match(type):
		self.TYPE_STRING:
			return "PackedStringArray"
		self.TYPE_INT:
			return "PackedInt64Array"
		self.TYPE_FLOAT:
			return "PackedFloat64Array"
		self.TYPE_BOOL:
			return "Array"
		self.TYPE_COLOR:
			return "PackedColorArray"
		self.TYPE_AABB:
			return "Array"
		self.TYPE_BASIS:
			return "Array"
		self.TYPE_PLANE:
			return "Array"
		self.TYPE_PROJ:
			return "Array"
		self.TYPE_QUAT:
			return "Array"
		self.TYPE_RECT:
			return "Array"
		self.TYPE_RESS:
			return "Array"
		self.TYPE_T2:
			return "Array"
		self.TYPE_T3:
			return "Array"
		self.TYPE_VECTOR2:
			return "PackedVector2Array"
		self.TYPE_VECTOR3:
			return "PackedVector3Array"
		self.TYPE_VECTOR4:
			return "Array"
		_:
			return "Array"

func _get_varType_to_String(type: int):
	
	match(type):
		self.TYPE_STRING:
			return "String"
		self.TYPE_INT:
			return "int"
		self.TYPE_FLOAT:
			return "float"
		self.TYPE_BOOL:
			return "bool"
		self.TYPE_COLOR:
			return "Color"
		self.TYPE_AABB:
			return "AABB"
		self.TYPE_BASIS:
			return "Basis"
		self.TYPE_PLANE:
			return "Plane"
		self.TYPE_PROJ:
			return "Projection"
		self.TYPE_QUAT:
			return "Quaternion"
		self.TYPE_RECT:
			return "Rect2"
		self.TYPE_RESS:
			return "Resource"
		self.TYPE_T2:
			return "Transform2D"
		self.TYPE_T3:
			return "Transform3D"
		self.TYPE_VECTOR2:
			return "Vector2"
		self.TYPE_VECTOR3:
			return "Vector3"
		self.TYPE_VECTOR4:
			return "Vector4"
		_:
			return "String"

func _convert_hard_to_soft_value(type: int, value: Variant):
	
	
	if typeof(value) == 9: # Check if the type of the value is a Vec3 (5 is the default TYPE_VECTOR3 of godot)
		return str("Vector3(",value.x,",",value.y,",",value.z,")")
	
	if typeof(value) == 5: # Check if the type of the value is a Vec2 (5 is the default TYPE_VECTOR2 of godot)
		return str("Vector2(",value.x,",",value.y,")")
	
	if typeof(value) == 4: # Check if the type of the value is a string (4 is the default TYPE_STRING of godot)
		if value == "[]":
			return value
	
	if type == self.TYPE_STRING:
		return str("\"", Datatable._convert_complex_string_to_data(type, value), "\"")
	
	var converted_data = Datatable._convert_complex_string_to_data(type, value)
	var new_value
	
	match(type):
		self.TYPE_COLOR:
			new_value = str("Color(",converted_data.r,",",converted_data.g,",",converted_data.b,",",converted_data.a,")")
		self.TYPE_VECTOR2:
			new_value = str("Vector2(",converted_data.x,",",converted_data.y,")")
		self.TYPE_VECTOR3:
			new_value = str("Vector3(",converted_data.x,",",converted_data.y,",",converted_data.z,")")
		self.TYPE_VECTOR4:
			new_value = str("Vector4(",converted_data.x,",",converted_data.y,",",converted_data.z,",",converted_data.w,")")
		self.TYPE_BOOL:
			if converted_data:
				new_value = "true"
			else:
				new_value = "false"
		self.TYPE_QUAT:
			new_value = str("Quaternion(",converted_data.x,",",converted_data.y,",",converted_data.z,",",converted_data.w,")")
		self.TYPE_RECT:
			new_value = str("Rect2(", converted_data.position.x, ", ", converted_data.position.y, ", ", converted_data.size.x, ", ", converted_data.size.y,")")
		self.TYPE_PLANE:
			new_value =  str("Plane(",converted_data.x,",",converted_data.y,",",converted_data.z,",",converted_data.d,")")
		self.TYPE_T2:
			new_value = str("Transform2D(",
			"Vector2",
			converted_data.x,",",
			"Vector2",
			converted_data.y,",",
			"Vector2(",
			converted_data.origin.x,",",
			converted_data.origin.y,
			"))")
		self.TYPE_T3:
			new_value =  str("Transform3D(",
			"Vector3",
			converted_data.basis.x,",",
			"Vector3",
			converted_data.basis.y,",",
			"Vector3",
			converted_data.basis.z,",",
			"Vector3(",
			converted_data.origin.x,",",
			converted_data.origin.y,",",
			converted_data.origin.z,
			"))")
		self.TYPE_AABB:
			new_value = str("AABB(Vector3(",
			converted_data.position.x,",",
			converted_data.position.y,",",
			converted_data.position.z,
			"),Vector3(",
			converted_data.size.x,",",
			converted_data.size.y,",",
			converted_data.size.z,
			"))")
		self.TYPE_BASIS:
			new_value = str("Basis(",
			"Vector3",
			converted_data.x,",",
			"Vector3",
			converted_data.y,",",
			"Vector3",
			converted_data.z,")")
		self.TYPE_PROJ:
			new_value = str("Projection(Vector4",converted_data.x,",Vector4",converted_data.y,",Vector4",converted_data.z,",Vector4",converted_data.w,")")
		self.TYPE_RESS:
			new_value = str("null")
		_:
			new_value = value
	
	return str(new_value)

func _get_getter(param: Dictionary):
	
	var name = param['name'].replace(' ', "_")
	var type_as_string
	
	if param['size'] == self.SIZE_SINGLE:
		type_as_string = _get_varType_to_String(param['type'])
	else:
		type_as_string = _get_varArray_to_String(param['type'])
	
	var getter_description: String = str("## This function can be used to get the ", name, " variable", "\n", "##", "\n", "## This function has been generated!")
	
	var content = str(getter_description, "\n", "func get_")
	
	# add name to func
	content += str(name, "() -> ")
	
	# add type to func
	content += str(type_as_string, ":\n")
	
	# add function content
	content += str("\treturn _", name, "\n")
	
	return content

func _get_setter(param: Dictionary):
	
	var name = param['name'].replace(' ', "_")
	var type_as_string
	
	if param['size'] == self.SIZE_SINGLE:
		type_as_string = _get_varType_to_String(param['type'])
	else:
		type_as_string = _get_varArray_to_String(param['type'])
	
	var getter_description: String = str("## This function can be used to set the ", name, " variable", "\n", "##", "\n", "## This function has been generated!")
	
	var content = str(getter_description, "\n", "func set_")
	
	# add name to func
	content += str(name, "(")
	
	# add arg to func
	content += str("new_value: ", type_as_string, "):\n")
	
	# add function content
	content += str("\t_",name," = new_value\n")
	
	return content

func _get_init(variables: Array):
	
	var init = ""
	
	var init_description: String = str(
		"## This is the constructor of the class"
	)
	
	var init_name: String = str(
		"func _init(data: Dictionary):"
	)
	
	var init_content = ""
	
	var temps_var = ""
	var finals_var = ""
	
	# Create temporary variable to use more simply in function
	
	for i in variables:
		var temp_var = str(
			"\tvar temp_", i, " = data['", i, "']"
			)
		temps_var += str(temp_var, "\n")
		
		var final_var = str(
			"\tset_", i, "(temp_", i, ")"
		)
		
		finals_var += str(final_var, "\n")
	
	# adding temporary variable
	
	init_content += temps_var
	
	# adding setter function to assign variable using temp var
	
	init_content += finals_var
	
	# adding to init
	init += str(
		init_description, "\n",
		init_name, "\n",
		temps_var, "\n",
		finals_var, "\n"
		)
	
	if temps_var == "":
		init += str(
			"\tpass"
		)
	
	return init
